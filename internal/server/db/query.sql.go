// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addUser = `-- name: AddUser :one
INSERT INTO "User" (email, name, username) VALUES ($1, $2, $3)
RETURNING id, name, email, image, username, email_verified, created_at, updated_at
`

type AddUserParams struct {
	Email    string
	Name     string
	Username string
}

func (q *Queries) AddUser(ctx context.Context, arg AddUserParams) (User, error) {
	row := q.db.QueryRow(ctx, addUser, arg.Email, arg.Name, arg.Username)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.Image,
		&i.Username,
		&i.EmailVerified,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createOAuthAccount = `-- name: CreateOAuthAccount :one
INSERT INTO "Account" (user_id, type, provider, provider_account_id, access_token, refresh_token, expires_at, token_type, scope, id_token, session_state)
VALUES ($1, "oauth", $2, $3, $4, $5, $6, $7, $8, $9, $10)
RETURNING id, user_id, type, provider, provider_account_id, access_token, refresh_token, expires_at, token_type, scope, id_token, session_state, created_at, updated_at
`

type CreateOAuthAccountParams struct {
	UserID            pgtype.UUID
	Provider          string
	ProviderAccountID string
	AccessToken       pgtype.Text
	RefreshToken      pgtype.Text
	ExpiresAt         pgtype.Timestamp
	TokenType         pgtype.Text
	Scope             pgtype.Text
	IDToken           pgtype.Text
	SessionState      pgtype.Text
}

func (q *Queries) CreateOAuthAccount(ctx context.Context, arg CreateOAuthAccountParams) (Account, error) {
	row := q.db.QueryRow(ctx, createOAuthAccount,
		arg.UserID,
		arg.Provider,
		arg.ProviderAccountID,
		arg.AccessToken,
		arg.RefreshToken,
		arg.ExpiresAt,
		arg.TokenType,
		arg.Scope,
		arg.IDToken,
		arg.SessionState,
	)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Type,
		&i.Provider,
		&i.ProviderAccountID,
		&i.AccessToken,
		&i.RefreshToken,
		&i.ExpiresAt,
		&i.TokenType,
		&i.Scope,
		&i.IDToken,
		&i.SessionState,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createSession = `-- name: CreateSession :one
INSERT INTO "Session" (session_token, refresh_token, expires_at, user_id) VALUES ($1, $2, $3, $4)
RETURNING id, session_token, refresh_token, expires_at, created_at, updated_at, user_id
`

type CreateSessionParams struct {
	SessionToken string
	RefreshToken string
	ExpiresAt    pgtype.Timestamp
	UserID       pgtype.UUID
}

func (q *Queries) CreateSession(ctx context.Context, arg CreateSessionParams) (Session, error) {
	row := q.db.QueryRow(ctx, createSession,
		arg.SessionToken,
		arg.RefreshToken,
		arg.ExpiresAt,
		arg.UserID,
	)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.SessionToken,
		&i.RefreshToken,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UserID,
	)
	return i, err
}

const createVerificationToken = `-- name: CreateVerificationToken :one
INSERT INTO "VerificationToken" (identifier, token, expires_at) VALUES ($1, $2, $3)
RETURNING identifier, token, expires_at
`

type CreateVerificationTokenParams struct {
	Identifier string
	Token      string
	ExpiresAt  pgtype.Timestamp
}

func (q *Queries) CreateVerificationToken(ctx context.Context, arg CreateVerificationTokenParams) (VerificationToken, error) {
	row := q.db.QueryRow(ctx, createVerificationToken, arg.Identifier, arg.Token, arg.ExpiresAt)
	var i VerificationToken
	err := row.Scan(&i.Identifier, &i.Token, &i.ExpiresAt)
	return i, err
}

const deleteSession = `-- name: DeleteSession :one
DELETE FROM "Session" WHERE session_token = $1
RETURNING session_token
`

func (q *Queries) DeleteSession(ctx context.Context, sessionToken string) (string, error) {
	row := q.db.QueryRow(ctx, deleteSession, sessionToken)
	var session_token string
	err := row.Scan(&session_token)
	return session_token, err
}

const deleteVerificationToken = `-- name: DeleteVerificationToken :one
DELETE FROM "VerificationToken" WHERE identifier = $1 AND token = $2
RETURNING identifier, token, expires_at
`

type DeleteVerificationTokenParams struct {
	Identifier string
	Token      string
}

func (q *Queries) DeleteVerificationToken(ctx context.Context, arg DeleteVerificationTokenParams) (VerificationToken, error) {
	row := q.db.QueryRow(ctx, deleteVerificationToken, arg.Identifier, arg.Token)
	var i VerificationToken
	err := row.Scan(&i.Identifier, &i.Token, &i.ExpiresAt)
	return i, err
}

const getAccountByProviderId = `-- name: GetAccountByProviderId :one
SELECT id, user_id, type, provider, provider_account_id, access_token, refresh_token, expires_at, token_type, scope, id_token, session_state, created_at, updated_at FROM "Account" WHERE provider = $1 AND provider_account_id = $2
`

type GetAccountByProviderIdParams struct {
	Provider          string
	ProviderAccountID string
}

func (q *Queries) GetAccountByProviderId(ctx context.Context, arg GetAccountByProviderIdParams) (Account, error) {
	row := q.db.QueryRow(ctx, getAccountByProviderId, arg.Provider, arg.ProviderAccountID)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Type,
		&i.Provider,
		&i.ProviderAccountID,
		&i.AccessToken,
		&i.RefreshToken,
		&i.ExpiresAt,
		&i.TokenType,
		&i.Scope,
		&i.IDToken,
		&i.SessionState,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getSessionUser = `-- name: GetSessionUser :one
SELECT id, email, name, username, image FROM "User" WHERE id = (SELECT user_id FROM "Session" WHERE session_token = $1)
`

type GetSessionUserRow struct {
	ID       pgtype.UUID
	Email    string
	Name     string
	Username string
	Image    pgtype.Text
}

func (q *Queries) GetSessionUser(ctx context.Context, sessionToken string) (GetSessionUserRow, error) {
	row := q.db.QueryRow(ctx, getSessionUser, sessionToken)
	var i GetSessionUserRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Name,
		&i.Username,
		&i.Image,
	)
	return i, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, name, email, image, username, email_verified, created_at, updated_at FROM "User" WHERE email = $1
`

// AUTH QUERIES
func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.Image,
		&i.Username,
		&i.EmailVerified,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getVerificationToken = `-- name: GetVerificationToken :one
SELECT identifier, token, expires_at FROM "VerificationToken" WHERE token = $1
`

func (q *Queries) GetVerificationToken(ctx context.Context, token string) (VerificationToken, error) {
	row := q.db.QueryRow(ctx, getVerificationToken, token)
	var i VerificationToken
	err := row.Scan(&i.Identifier, &i.Token, &i.ExpiresAt)
	return i, err
}

const newOAuthUserTransaction = `-- name: NewOAuthUserTransaction :one
WITH new_user AS (
    INSERT INTO "User" (email, name, image, username, email_verified) 
    VALUES ($1, $2, $3, $4, $5)
    RETURNING id, name, email, image, username, email_verified, created_at, updated_at
),
new_account AS (
    INSERT INTO "Account" (user_id, type, provider, provider_account_id, access_token, refresh_token, expires_at, token_type, scope, id_token, session_state)
    VALUES ((SELECT id FROM new_user), 'oauth', $6, $7, $8, $9, $10, $11, $12, $13, $14)
    RETURNING id, user_id, type, provider, provider_account_id, access_token, refresh_token, expires_at, token_type, scope, id_token, session_state, created_at, updated_at
)
SELECT 
    new_user.id as user_id,
    new_user.email,
    new_user.name,
    new_user.username,
    new_user.image,
    new_user.email_verified,
    new_account.id as account_id,
    new_account.provider,
    new_account.provider_account_id
FROM new_user, new_account
`

type NewOAuthUserTransactionParams struct {
	Email             string
	Name              string
	Image             pgtype.Text
	Username          string
	EmailVerified     pgtype.Timestamp
	Provider          string
	ProviderAccountID string
	AccessToken       pgtype.Text
	RefreshToken      pgtype.Text
	ExpiresAt         pgtype.Timestamp
	TokenType         pgtype.Text
	Scope             pgtype.Text
	IDToken           pgtype.Text
	SessionState      pgtype.Text
}

type NewOAuthUserTransactionRow struct {
	UserID            pgtype.UUID
	Email             string
	Name              string
	Username          string
	Image             pgtype.Text
	EmailVerified     pgtype.Timestamp
	AccountID         pgtype.UUID
	Provider          string
	ProviderAccountID string
}

func (q *Queries) NewOAuthUserTransaction(ctx context.Context, arg NewOAuthUserTransactionParams) (NewOAuthUserTransactionRow, error) {
	row := q.db.QueryRow(ctx, newOAuthUserTransaction,
		arg.Email,
		arg.Name,
		arg.Image,
		arg.Username,
		arg.EmailVerified,
		arg.Provider,
		arg.ProviderAccountID,
		arg.AccessToken,
		arg.RefreshToken,
		arg.ExpiresAt,
		arg.TokenType,
		arg.Scope,
		arg.IDToken,
		arg.SessionState,
	)
	var i NewOAuthUserTransactionRow
	err := row.Scan(
		&i.UserID,
		&i.Email,
		&i.Name,
		&i.Username,
		&i.Image,
		&i.EmailVerified,
		&i.AccountID,
		&i.Provider,
		&i.ProviderAccountID,
	)
	return i, err
}

const updateOAuthAccount = `-- name: UpdateOAuthAccount :one
UPDATE "Account"
SET access_token = $2,
    refresh_token = $3,
    expires_at = $4,
    token_type = $5,
    scope = $6,
    id_token = $7,
    session_state = $8
WHERE user_id = $9 AND provider = $10 AND provider_account_id = $1
RETURNING id, user_id, type, provider, provider_account_id, access_token, refresh_token, expires_at, token_type, scope, id_token, session_state, created_at, updated_at
`

type UpdateOAuthAccountParams struct {
	ProviderAccountID string
	AccessToken       pgtype.Text
	RefreshToken      pgtype.Text
	ExpiresAt         pgtype.Timestamp
	TokenType         pgtype.Text
	Scope             pgtype.Text
	IDToken           pgtype.Text
	SessionState      pgtype.Text
	UserID            pgtype.UUID
	Provider          string
}

func (q *Queries) UpdateOAuthAccount(ctx context.Context, arg UpdateOAuthAccountParams) (Account, error) {
	row := q.db.QueryRow(ctx, updateOAuthAccount,
		arg.ProviderAccountID,
		arg.AccessToken,
		arg.RefreshToken,
		arg.ExpiresAt,
		arg.TokenType,
		arg.Scope,
		arg.IDToken,
		arg.SessionState,
		arg.UserID,
		arg.Provider,
	)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Type,
		&i.Provider,
		&i.ProviderAccountID,
		&i.AccessToken,
		&i.RefreshToken,
		&i.ExpiresAt,
		&i.TokenType,
		&i.Scope,
		&i.IDToken,
		&i.SessionState,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateSession = `-- name: UpdateSession :one
UPDATE "Session" SET session_token = $1, refresh_token = $2, expires_at = $3 WHERE session_token = $4
RETURNING id, session_token, refresh_token, expires_at, created_at, updated_at, user_id
`

type UpdateSessionParams struct {
	SessionToken   string
	RefreshToken   string
	ExpiresAt      pgtype.Timestamp
	SessionToken_2 string
}

func (q *Queries) UpdateSession(ctx context.Context, arg UpdateSessionParams) (Session, error) {
	row := q.db.QueryRow(ctx, updateSession,
		arg.SessionToken,
		arg.RefreshToken,
		arg.ExpiresAt,
		arg.SessionToken_2,
	)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.SessionToken,
		&i.RefreshToken,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UserID,
	)
	return i, err
}

const updateUserVerification = `-- name: UpdateUserVerification :one
UPDATE "User" SET email_verified = $2 WHERE email = $1
RETURNING id, name, email, image, username, email_verified, created_at, updated_at
`

type UpdateUserVerificationParams struct {
	Email         string
	EmailVerified pgtype.Timestamp
}

func (q *Queries) UpdateUserVerification(ctx context.Context, arg UpdateUserVerificationParams) (User, error) {
	row := q.db.QueryRow(ctx, updateUserVerification, arg.Email, arg.EmailVerified)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.Image,
		&i.Username,
		&i.EmailVerified,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
